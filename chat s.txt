00:17:09	Felicia Dizmond:	The code violates encapsulation. (1) The code should directly write the get method and implement it from the ArrayList instead of creating a method called myGet within MyList class. (2) object aList should be created outside of a method so it can be accessed by other methods.
00:17:10	Brendan O'Malley:	getter should be called “getIndex” and return a value, not a call to another function and it should not be taking in any parameters; it does not make the code readable to humans with a declaration such as “myGet”
00:17:10	Kenny Murillo:	encapsulation - aList components aren't necessarily private, and the instance method should be a proper getter
00:17:11	Adrian Bruno:	Breaking the Bean property convention and encapsulation by calling an overridable method get() within the child class. Need to make sure that get doesn't do anything other than retrieve the data at that index or else undefined behaviour could occur. Main method in the same class as the object that it is declaring and initializin.
00:17:11	Clinton Rasnick:	Does not follow bean convention and has a main class. I think I’m wrong though and probably need to finish A1 to understand more.
00:17:11	Michaelanthony Gore:	"myGet" fills the same role as existing methods in the class it extends, creating redundancy and violating the principle of public method use. The use of multiple methods, both public, means that instead of repurposing the class, time is spent creating a new class unnecessarily.
00:17:11	Alice (Xiaoyue) Zhang:	I’m not sure but one principle that might be violated is that when creating a variable, we should use the interface as the type
00:17:11	Alexander Wigger:	Getters don’t have parameters normally? And the return getter doesn’t have the type in the method name? The rationale for these principles is to have a universal and easy to understand coding style? Also you are allowed to say ArrayList aList = new MyList(); instead
00:17:11	Elad Ohana:	1. main method in structural class, 2. run-time should be performed in the class that will run the program. Rationale is to that a class should only have code that is directly relevant to its own structure so that it can be properly reused
00:17:12	Drayton Wingler:	1) There's no constructor, and 2) the methods for MyList don't do anything functionally different from the methods of ArrayList
00:17:13	Aayush Singh:	Does it have to do with data encapsulation? The inner working of classes should be hidden from one another, but through inheritance they end up being dependent?
00:17:13	Felipe Yanaga:	1.	aList Should be declared as “parent” class instead of its own class. So when declaring aList, the type should have been ArrayList, instead of MyList – similar to an interface/implementation rationale.
2.	Other mistake is that “myGet” is dependent on the get method, which is not necessarily ideal, since we have no control over what it returns. Similar to “don’t create new instances for every get” in A1.
00:17:14	Ethan Jacob:	1. The class is public, violating encapsulation/ the need to know principle 2. Violates the separation of concerns principle since ArrayList already has a getter. You need different methods to make this a useful class
00:17:15	Reed Frellick:	Do not have a main method outside of a main class, and name getters using the format getSomething(). The rationale is to have consistently well organized and easily understood projects, classes, and methods that others can observe and also understand.
00:17:15	Gabriel Mercado Mendez:	First we are giving MyList as a Type instead of the Interface ArrayList as the Type
Second it is not using convention getter names to  indicate a propertie exists.

The rationale for using interface as a Type is to make your code more reusable as well as consistent. By using interface as a Type we could later use some other implementation of Arraylist and give it our MyList object properties to instantiate it.
The rationale for using convention names is such that Java knows what properties compose your class. Right now this code has no properties following conventional syntax.
00:17:16	Shriya Mandal:	myGet is not the proper name for a getter, and there is no interfacehaving a proper name for a getter is important because it makes it easy to see the properties of the code, and an interface is important because it specifies the behavior of a class and it can be used for inheritance
00:17:17	Andrew Byerle:	The instantiation of aList uses an incorrect type MyList, and doesn’t have an interface (Encapsulation). The getter returns the index instead of a component at the specified index.
00:17:17	Chongyi Zheng:	Custom class shouldn’t define any public method that is not declared in the interface. The class that extends another class shouldn’t have a main method defined.
00:17:19	Maya Theresa Gopal:	The myGet method calls another get method not specified in the code. The type of aList should be the interface of MyList. This allows you more flexibility when doing assignment, especially if we have a polymorphic method. Moreover, each public method should be listed in an interface, which we don’t see here. Using interfaces is important because they give specific requirements needed for an implementation.
00:17:23	Callie Xu:	the method is titled myGet rather than what a getter method should be titled? the rationale would be that the getter should be titled the same way to follow bean convention, another principle would be the aList extending MyList
00:17:43	Brantley Wiggins:	Does not follow Bean convention: get and set methods must be prefaced with get/set. Property annotations are missing from class. myGet should be in an interface before making instance of class. Bean convention and property annotations help mitigate coding errors by ensuring a class has proper properties.
00:19:14	Wid Alsadoon:	The class is public which doesn't follow encapsulation as well as there being no constructor. Encapsulation is important as the rationale for it being that we keep all the information hidden. Constructor allows for instantiation of the class.
00:19:29	Yutong Wang:	Should have a super? Instantiation should show specific category of data? 
00:19:42	Reed Frellick:	Do not have a main method outside of a main class, and name getters using the format getSomething(). The rationale is to have consistently well organized and easily understood projects, classes, and methods that others can observe and also understand. (Apologies if this already sent, I’m on a hotspot on the road)
00:20:56	Fariha Marzan:	This violates the principle of encapsulation that doesn’t directly write the get method and the idea that data inside the object should only be accessed through a public interface.
00:23:52	Ethan Jacob:	My mic is not working but it was in the praxes I think
00:49:25	Clinton Rasnick:	Polymorphism wasn’t covered
00:58:41	Gabriel Mercado Mendez:	Thanks
00:58:51	Lam (he/him):	thank you for class today!
00:58:59	Elad Ohana:	Thank you!
00:59:12	Justin Do:	good luck on the assignment all!
01:15:03	Ken Liu:	File helperConfigFolder = new File(System.getProperty("user.home"), "helper-config");
